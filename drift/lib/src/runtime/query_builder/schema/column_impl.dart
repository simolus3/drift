part of '../query_builder.dart';

const VerificationResult _invalidNull = VerificationResult.failure(
    "This column is not nullable and doesn't have a default value. "
    "Null fields thus can't be inserted.");

/// Implementation for a [Column] declared on a table.
class GeneratedColumn<T> extends Column<T> {
  /// The sql name of this column.
  final String $name; // todo: Remove, replace with `name`

  /// The name of the table that contains this column
  final String tableName;

  /// Whether null values are allowed for this column.
  final bool $nullable;

  /// Default constraints generated by drift.
  final String? _defaultConstraints;

  /// Custom constraints that have been specified for this column.
  ///
  /// Some constraints, like `NOT NULL` or checks for booleans, are generated by
  /// drift by default.
  /// Constraints can also be overridden with [BuildColumn.customConstraint],
  /// in which case the drift constraints will not be applied.
  final String? $customConstraints;

  /// The default expression to be used during inserts when no value has been
  /// specified. Can be null if no default value is set.
  final Expression<T>? defaultValue;

  /// A function that yields a default column for inserts if no value has been
  /// set. This is different to [defaultValue] since the function is written in
  /// Dart, not SQL. It's a compile-time error to declare columns where both
  /// [defaultValue] and [clientDefault] are non-null.
  ///
  /// See also: [BuildColumn.clientDefault].
  final T Function()? clientDefault;

  /// Additional checks performed on values before inserts or updates.
  final VerificationResult Function(T, VerificationMeta)? additionalChecks;

  /// The sql type name, such as TEXT for texts.
  final String typeName;

  /// Whether a value is required for this column when inserting a new row.
  final bool requiredDuringInsert;

  /// Whether this column has an `AUTOINCREMENT` primary key constraint that was
  /// created by drift.
  bool get hasAutoIncrement =>
      _defaultConstraints?.contains('AUTOINCREMENT') == true;

  @override
  String get name => $name;

  /// Used by generated code.
  GeneratedColumn(
    this.$name,
    this.tableName,
    this.$nullable, {
    this.clientDefault,
    required this.typeName,
    String? defaultConstraints,
    this.$customConstraints,
    this.defaultValue,
    this.additionalChecks,
    this.requiredDuringInsert = false,
  }) : _defaultConstraints = defaultConstraints;

  /// Applies a type converter to this column.
  ///
  /// This is mainly used by the generator.
  GeneratedColumnWithTypeConverter<D, T> withConverter<D>(
      TypeConverter<D, T> converter) {
    return GeneratedColumnWithTypeConverter._(
      converter,
      $name,
      tableName,
      $nullable,
      clientDefault,
      typeName,
      _defaultConstraints,
      $customConstraints,
      defaultValue,
      additionalChecks,
      requiredDuringInsert,
    );
  }

  /// Writes the definition of this column, as defined
  /// [here](https://www.sqlite.org/syntax/column-def.html), into the given
  /// buffer.
  void writeColumnDefinition(GenerationContext into) {
    final isSerial = into.dialect == SqlDialect.postgres &&
        typeName == 'INTEGER' &&
        _defaultConstraints == 'PRIMARY KEY AUTOINCREMENT';

    if (isSerial) {
      into.buffer.write('$escapedName SERIAL PRIMARY KEY NOT NULL');
    } else {
      into.buffer.write('$escapedName $typeName');
    }

    if ($customConstraints == null) {
      if (!isSerial) {
        into.buffer.write($nullable ? ' NULL' : ' NOT NULL');
      }

      final defaultValue = this.defaultValue;
      if (defaultValue != null) {
        into.buffer.write(' DEFAULT ');

        // we need to write brackets if the default value is not a literal.
        // see https://www.sqlite.org/syntax/column-constraint.html
        final writeBrackets = !defaultValue.isLiteral;

        if (writeBrackets) into.buffer.write('(');
        defaultValue.writeInto(into);
        if (writeBrackets) into.buffer.write(')');
      }

      // these custom constraints refer to builtin constraints from drift
      if (!isSerial && _defaultConstraints != null) {
        into.buffer
          ..write(' ')
          ..write(_defaultConstraints);
      }
    } else if ($customConstraints?.isNotEmpty == true) {
      into.buffer
        ..write(' ')
        ..write($customConstraints);
    }
  }

  @override
  void writeInto(GenerationContext context, {bool ignoreEscape = false}) {
    if (context.hasMultipleTables) {
      context.buffer
        ..write(tableName)
        ..write('.');
    }
    context.buffer.write(ignoreEscape ? $name : escapedName);
  }

  /// Checks whether the given value fits into this column. The default
  /// implementation only checks for nullability, but subclasses might enforce
  /// additional checks. For instance, a text column might verify that a text
  /// has a certain length.
  VerificationResult isAcceptableValue(T value, VerificationMeta meta) {
    final nullOk = $nullable;
    if (!nullOk && value == null) {
      return _invalidNull;
    } else {
      return additionalChecks?.call(value, meta) ??
          const VerificationResult.success();
    }
  }

  /// A more general version of [isAcceptableValue] that supports any sql
  /// expression.
  ///
  /// The default implementation will not perform any check if [value] is not
  /// a [Variable].
  VerificationResult isAcceptableOrUnknown(
      Expression value, VerificationMeta meta) {
    if (value is Variable) {
      return isAcceptableValue(value.value as T, meta);
    } else {
      return const VerificationResult.success();
    }
  }

  @override
  int get hashCode => Object.hash(tableName, $name);

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) return false;

    // ignore: test_types_in_equals
    final typedOther = other as GeneratedColumn;
    return typedOther.tableName == tableName && typedOther.$name == $name;
  }

  Variable _evaluateClientDefault() {
    return Variable<T>(clientDefault!());
  }

  /// A value for [additionalChecks] validating allowed text lengths.
  ///
  /// Used by generated code.
  static VerificationResult Function(String?, VerificationMeta) checkTextLength(
      {int? minTextLength, int? maxTextLength}) {
    return (value, meta) {
      if (value == null) return const VerificationResult.success();

      final length = value.length;
      if (minTextLength != null && minTextLength > length) {
        return VerificationResult.failure(
            'Must at least be $minTextLength characters long.');
      }
      if (maxTextLength != null && maxTextLength < length) {
        return VerificationResult.failure(
            'Must at most be $maxTextLength characters long.');
      }

      return const VerificationResult.success();
    };
  }
}

/// A [GeneratedColumn] with a type converter attached to it.
///
/// This provides the [equalsValue] method, which can be used to compare this
/// column against a value mapped through a type converter.
class GeneratedColumnWithTypeConverter<D, S> extends GeneratedColumn<S> {
  /// The type converted used on this column.
  final TypeConverter<D, S> converter;

  GeneratedColumnWithTypeConverter._(
    this.converter,
    String name,
    String tableName,
    bool nullable,
    S Function()? clientDefault,
    String typeName,
    String? defaultConstraints,
    String? customConstraints,
    Expression<S>? defaultValue,
    VerificationResult Function(S, VerificationMeta)? additionalChecks,
    bool requiredDuringInsert,
  ) : super(
          name,
          tableName,
          nullable,
          clientDefault: clientDefault,
          typeName: typeName,
          defaultConstraints: defaultConstraints,
          $customConstraints: customConstraints,
          defaultValue: defaultValue,
          additionalChecks: additionalChecks,
          requiredDuringInsert: requiredDuringInsert,
        );

  /// Compares this column against the mapped [dartValue].
  ///
  /// The value will be mapped using the [converter] applied to this column.
  Expression<bool> equalsValue(D? dartValue) {
    return equals(converter.mapToSql(dartValue) as S);
  }
}
